დასახელება: ვაკეთებთ mymarket ტიპის აპლიკაციისთვის back-end აპლიკაციას, სადაც მომხმარებლები გაყიდიან თავიანთ პროდუქტებს

// ცხრილები
1. POSTGRES: შექმენით მომხმარებლების ცხრილი (id, firstName, lastName, balance, email, password, userType, createdAt, updatedAt, deletedAt, isAdmin = true | false )

2. POSTGRES: შექმენით პროდუქტების ცხრილი (id, title, description, price, soldAt, createdAt, updatedAt, deletedAt, userId, typeId) 
	პროდუქტებს უნდა ჰქონდეთ დასახელება, აღწერა, ღირებულება, შექმნის/განახლების/წაშლის თარიღები, მომხმარებლის id, რომელსაც ეკუთვნის, თუ როდის გაიყიდა ( თუ გაიყიდა რა თქმა უნდა) 

3. POSTGRES: შექმენით პროდუქტების ტიპების ცხრილი, მაგ: ('electronics', 'clothing') და ა.შ ( კრეატივი თქვენთვის მომინდია)

4. POSTGRES: უნდა გვქონდეს ტრანზაქციების ცხრილი (id, sellerId, buyerId, productId, price, createdAt)

5. OPTIONAL: MONGO: შექმენით ლოგირების ცხრილი: _id, previousValue, currentValue, field, type, recordId 
	- field: კონკრეტულ ცხრილში რომელიმე column, მაგალითად firstName, email, isAdmin
	- type: უკვე რომელ ცხრილს ეხება ეს, მაგალითად 'Users', 'Products' ... 
    - recordId: კონკრეტული ცხრილის რეკორტის primary key, მაგალითად users.id, products.id 

	უნდა გვქონდეს ლოგირების ბაზა (mongo) და ლოგირების ფუნქციონალი (დამატებისას, რედაქტირებისას, წაშლისას), 
რედაქტირების შემთხვევაში უნდა ჩაწეროთ სათითაოდ რა field-ები შეიცვალა ცალკეულ ჩანაწერებად


---------------------------------------------

// auth
6. უნდა გვქონდეს რეგისტრაცია ( პაროლები უნდა იყოს დაჰეშილი bcrypt (https://www.npmjs.com/package/bcrypt))

7. მომხმარებლებს უნდა შეეძლოთ ავტორიზაცია/აუთენთიკაცია JWT TOKEN

8. უნდა გქვონდეს აუთენთიკაციის მიდლვეარი, აუთენთიფიცირებულობის შესამოწმებლად


-----------------
// error

9. უნდა გვქონდეს ერორჰენდლერი და ჩვენ მიერ შექმნილი exceptions


----------------

10. მომხმარებლებს უნდა შეეძლოთ პროდუქტის დამატება, წაშლა, რედაქტირება ( მხოლოდ თავიანთი პროდუქტის, ანუ ეს დაცვაც უნდა ჩაამატოთ რამენაირად, რომ სხვის პროდუქტთან ნახვის გარდა არაფრის საშუალება არ ჰქონდეს მომხმარებელს), დაამატეთ ვალიდაციები, რომ უკვე გაყიდული პროდუქტის რედაქტირება არ შეიძლებოდეს და ა.შ


11. უნდა გვყავდეს ერთი ადმინ მომხმარებელი, რომელსაც შეეძლება სხვა მომხარებლების და ასევე საჭიროების შემთხვევაში ამ მომხმარებლების პროდუქტების წაშლა (დამატება და რედაქტირება არა, მხოლოდ წაშლა. პს: ლოგიკურია ისეთი პროდუქტების რომლებიც უკვე გაყიდული არ არის, ანუ გასაყიდია)

13. მომხმარებლებს უნდა შეეძლოთ ერთმანეთის პროდუქტის ყიდვა, რომელიც ჩაიწერება ტრანზაქციების კოლექციაში. შესაბამისად უნდა შექმნათ ამის APIs

14. (get /sell-statistic) უნდა დაწეროთ ერთი სტატისტიკის api, რომელ წლის და თვის მიხედვითაც ოდესმე ყოფილა გაყიდვები (from sellsHistory), უნდა დააჯგუფოს და ერთიანად წამოიღოს ჯამური ღირებულებების რაოდენობა, მაგალითად : {
	2021: {
		1: 1500,
		3: 3500,
	}

	
	// sum function + group by + date functions. Transaction.sum(....., group: [Sequelize.fn('year', 'createdAt'), Sequelize.fn('month', 'createdAt')]
}


15: ყველა API-ს უნდა ქონდეს ვალიდაციები, გამოიყენეთ JOI ვალიდატორი


---------------------

პს: 
	1) მექანიკური შეცდომებისგან თავის ასარიდებლად გამოიყენეთ esLint
	2) დააკომიტეთ თქვენი ცვლილებები სწორად, მაგალითად: error-handler-ის გაკეთებისას შექმენით კომითი "add error handling", 
	სტატისტიკის API'ს შექმნის დროს "add statistics api" და ა.შ, ეს დაგეხმარებთა აკონტროლოთ თქვენი პროგრესი პროექტის კეთებისას